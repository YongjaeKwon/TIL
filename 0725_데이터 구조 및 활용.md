# 데이터 구조

* 순서가 있는 데이터 구조
  
  * 문자열(String)
  
  * 리스트(List)
  
  * 튜플(Tuple)

* 순서가 없는 데이터 구조
  
  * 셋(Set)
  
  * 딕셔너리(Dictionary)

* 얕은 복사와 깊은 복사

## 순서가 있는 데이터 구조 (시퀀스형 데이터 구조)

### 문자열(String Type)

* 문자들의 나열(sequence of characters)
  
  * 모든 문자는 str타입 (변경 불가능한 immutable)

* 문자열은 작은 따옴표(')나 큰 따옴표(")를 활용하여 표기
  
  * 문자열을 묶을 때 동일한 문장부호를 활용
  
  * PEP8에서는 소스코드 내에서 하나의 문장부호를 선택하여 유지하도록 함

> 문자열 조회/탐색 및 검증 메서드

![](0725_데이터%20구조%20및%20활용_assets/2022-07-26-11-12-53-image.png)

> 문자열 조회/탐색
> 
> * .find(x)
>   
>   * x의 첫 번째 위치를 반환. 없으면, -1을 반환함. (오류가 나지 않음)
> 
> * .index(x)
>   
>   * x의 첫 번째 위치를 반환. 없으면, 오류발생

> 문자열 변경 메서드(s는 문자열)

![](0725_데이터%20구조%20및%20활용_assets/2022-07-26-11-15-31-image.png)

> 문자열은 immutable(불변형)인데, 문자열 변경이 되는 이유?
> 
> * 기존의 문자열을 변경하는 게 아니라, 변경된 문자열을 새롭게 만들어서 반환
>   
>   * ex)replace, strip, title 등

> 문자열 변경
> 
> * .replace(old, new[,count]))
>   
>   * 바꿀 대상 글자를 새로운 글자로 바꿔서 반환
>   
>   * count를 지정하면, 해당 개수만큼만 시행
> 
> * .strip([chars])
>   
>   * 특정한 문자들을 지정하면,
>     
>     * 양쪽을 제거하거나(strip), 왼쪽을 제거하거나(lstrip), 오른쪽을 제거(rstrip)
>   
>   * 문자열을 지정하지 않으면 공백을 제거함
> 
> * .split(sep = None, maxsplit = -1)
>   
>   * 문자열을 특정한 단위로 나눠 리스트로 반환
>     
>     * sep이 None이거나 지정되지 않으면 연속된 공백문자를 단일한 공백문자로 간주하고, 선행/후행 공백은 빈 문자열에 포함시키지 않음.
>     
>     * maxsplit이 -1 인 경우에는 제한이 없음.
> 
> * 'separator'.join([iterable])
>   
>   * 반복가능한(iterable) 컨테이너 요소들을 separator(구분자)로 합쳐 문자열 반환
>     
>     * iterable에 문자열이 아닌 값이 있으면 TypeError 발생

### 리스트(list)

* 리스트는 여러 개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용

> 리스트의 생성과 접근
> 
> * 리스트는 대괄호([]) 혹은 list()를 통해 생성
>   
>   * 파이썬에서는 어떠한 자료형도 저장할 수 있으며, 리스트 안에 리스트도 넣을 수 있음
>   
>   * 생성된 이후 내용 변경이 가능 -> 가변 자료형
>   
>   * 이러한 유연석 때문에 파이썬에서 가장 흔히 사용
> 
> * 순서가 있는 시퀀스로 인덱스를 통해 접근 가능
>   
>   * 값에 대한 접근은 list[i] (리스트의 첫번째 인덱스는 0으로 시작한다.)

> **리스트 메서드**

![](0725_데이터%20구조%20및%20활용_assets/2022-07-26-16-18-20-image.png)

> **값 추가 및 삭제**
> 
> * .append(x)
>   
>   * 리스트에 값을 추가함
> 
> * .insert(i, x)
>   
>   * 정해진 위치 i 에 x 값을 추가함
> 
> * .extend(iterable)
>   
>   * 리스트에 iterable의 항목을 추가함
> 
> * .remove(x)
>   
>   * 리스트에서 값이 x인 것 삭제
> 
> * .pop(i)
>   
>   * 정해진 위치 i에 있는 값을 삭제하고, 그 항목을 반환함
>   
>   * i가 지정되지 않으면, 마지막 항목을 삭제하고 반환함
> 
> * .clear()
>   
>   * 모든 항목을 삭제함

> **탐색 및 정렬**
> 
> * .index(x)
>   
>   * x값을 찾아 해당 index값을 반환
> 
> * . count(x)
>   
>   * 원하는 값의 개수를 반환함
> 
> * .sort()
>   
>   * 원본 리스트를 정렬함. None 반환
>   
>   * sorted 함수와 비교할 것
> 
> * .reverse()
>   
>   * 순서를 반대로 뒤집음(정렬하는 것이 아님)

### 튜플

> **튜플의 정의**
> 
> * 튜플은 여러개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용
>   
>   * 리스트와의 차이점은 생성 후, 담고 있는 값 변경이 불가 (불변 자료형)
> 
> * 항상 소괄호 형태로 사용

> 튜플 관련 메서드
> 
> * 튜플은 변경할 수 없기 때문에 값에 영향을 미치지 않는 메서드만을 지원
> 
> * 리스트 메서드 중 항목을 변경하는 메서드들을 제외하고 대부분 동일

## 비시퀀스형 데이터 구조

### 셋(set)

* Set이란 중복되는 요소가 없이, 순서에 상관없는 데이터들의 묶음
  
  * 데이터의 중복을 허용하지 않기 때문에 중복되는 원소가 있다면 하나만 저장
  
  * 순서가 없기 때문에 인덱스를 이용한 접근 불가능

* 수학에서의 집합을 표현한 컨테이너
  
  * 집합 연산이 가능(여집합을 표현하는 연산자는 별도로 존재X)
  
  * 중복된 값이 존재하지 않음

* 담고 있는 요소를 삽입 변경, 삭제 가능 -> 가변 자료형 (mutable)
  
  > **Set 메서드(s는 set)**

![](0725_데이터%20구조%20및%20활용_assets/2022-07-26-16-27-48-image.png)

> **추가 및 변경**
> 
> * .add(elem)
>   
>   * 셋에 값을 추가
> 
> * .update(\*others)
>   
>   * 여러 값을 추가



> **요소 삭제**
> 
> - .remove(elem)
>   
>   - SET에서 삭제하고, 없으면 KeyError
> 
> - .discard(elem)
>   
>   - 셋에서 삭제하고 없어도 에러가 발생하지 않음



> **삭제**
> 
> * .pop()
>   
>   * 임의의 원소를 제거해 반환



> **모두 삭제**
> 
> * .clear()
>   
>   * 모든 항목을 제거



> **집합 관련 함수**
> 
> * s.isdiscoint(t)
>   
>   * 셋 s가 셋t의 서로 같은 항목을 하나라도 갖고 있지 않은 경우, True반환(서로소)
> 
> * s.issubset(t)
>   
>   * 셋s가 셋t의 하위 셋인 경우, True 반환
> 
> * s.issuperset(t)
>   
>   * 셋s가 셋t의 상위 셋인 경우, True 반환

### 딕셔너리(Dictionary)

* 키-값(key-value) 쌍으로 이뤄진 자료형

* Dictionary의 키(Key)
  
  * Key는 변경 불가능한 데이터(immutable)만 활용 가능
    
    * string, integer, float, boolean, tuple, range

* 각 키의 값(values)
  
  * 어떠한 형태든 관계없음

![](0725_데이터%20구조%20및%20활용_assets/2022-07-26-16-41-35-image.png)

> **딕셔너리 메서드(d는 딕셔너리)**

![](0725_데이터%20구조%20및%20활용_assets/2022-07-26-16-42-13-image.png)

> 조회
> 
> * .get(key[,default)
>   
>   * key를 통해 value를 가져옴
>   
>   * KeyError가 발생하지 않으며, default 값을 설정할 수 있음(기본: None)

> 추가 및 삭제
> 
> * .pop(key[,default])
>   
>   * key가 딕셔너리에 있으면 제거하고 해당 값을 반환
>   
>   * 그렇지 않으면 default를 반환
>   
>   * default값이 없으면 KeyError
> 
> * .update()
>   
>   * 값을 제공하는 key, value로 덮어씁니다.

### **얕은 복사와 깊은 복사 (Shallow Copy & Deep Copy)**

#### 복사방법

* 할당 (Assignment)

* 얕은 복사 (Shallow copy)

* 깊은 복사 (Deep copy)

> **할당**
> 
> * 대입 연산자 (=)
>   
>   * 리스트 복사 확인하기
>     
>     * 대입 연산자 (=)를 통한 복사는 해당 객체에 대한 객체 참조를 복사
>     
>     * 해당 주소의 일부 값을 변경하는 경우 이를 참조하는 모든 변수에 영향

> **얕은 복사 (shallow copy)**
> 
> * Slice 연산자 활용하여 같은 원소를 가진 리스트지만 연산된 결과를 복사 (다른주소)
> 
> * 복사하는 리스트의 원소가 주소를 참조하는 경우 (주의 해야 할 상황)

> **깊은 복사 (deep copy)**
> 
> * .deepcopy()




